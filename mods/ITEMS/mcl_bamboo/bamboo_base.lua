---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by michieal.
--- DateTime: 12/29/22 12:33 PM -- Restructure Date
---

-- LOCALS
local modname = minetest.get_current_modname()
local S = minetest.get_translator(modname)
local bamboo = "mcl_bamboo:bamboo"
local bamboo_one = bamboo .."_1"
local bamboo_two = bamboo.."_2"
local bamboo_three = bamboo.."_3"
local node_sound = mcl_sounds.node_sound_wood_defaults()

-- CONSTS
local DOUBLE_DROP_CHANCE = 8
local DEBUG = false

local strlen = string.len
local substr = string.sub
local pr = PseudoRandom(os.time() * 12 + 15766) -- switched from math.random() to PseudoRandom because the random wasn't very random.

local on_rotate
if minetest.get_modpath("screwdriver") then
	on_rotate = screwdriver.disallow
end

-- basic bamboo nodes.
local bamboo_def = {
	description = "Bamboo",
	tiles = {"mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo.png"},
	drawtype = "nodebox",
	paramtype = "light",
	groups = {handy = 1, axey = 1, choppy = 1, flammable = 3},
	sounds = node_sound,

	drop = {
		max_items = 1,
		-- Maximum number of item lists to drop.
		-- The entries in 'items' are processed in order. For each:
		-- Item filtering is applied, chance of drop is applied, if both are
		-- successful the entire item list is dropped.
		-- Entry processing continues until the number of dropped item lists
		-- equals 'max_items'.
		-- Therefore, entries should progress from low to high drop chance.
		items = {
			-- Examples:
			{
				-- 1 in 100 chance of dropping.
				-- Default rarity is '1'.
				rarity = DOUBLE_DROP_CHANCE,
				items = {bamboo .. " 2"},
			},
			{
				-- 1 in 2 chance of dropping.
				-- Default rarity is '1'.
				rarity = 1,
				items = {bamboo},
			},
		},
	},

	inventory_image = "mcl_bamboo_bamboo_shoot.png",
	wield_image = "mcl_bamboo_bamboo_shoot.png",
	_mcl_blast_resistance = 1,
	_mcl_hardness = 1.5,
	node_box = {
		type = "fixed",
		fixed = {
			{-0.175, -0.5, -0.195, 0.05, 0.5, 0.030},
		}
	},
	collision_box = {
		type = "fixed",
		fixed = {
			{-0.175, -0.5, -0.195, 0.05, 0.5, 0.030},
		}
	},
	selection_box = {
		type = "fixed",
		fixed = {
			{-0.175, -0.5, -0.195, 0.05, 0.5, 0.030},
		}
	},

	on_rotate = on_rotate,

	on_place = function(itemstack, placer, pointed_thing)
		if pointed_thing.type ~= "node" then
			return itemstack
		end
		local node = minetest.get_node(pointed_thing.under)
		local pos = pointed_thing.under
		local nodename = node.name

		if DEBUG then
			minetest.log("mcl_bamboo::Node placement data:")
			minetest.log(dump(pointed_thing))
			minetest.log(node.name)
		end

		if DEBUG then
			minetest.log("mcl_bamboo::Checking for protected placement of bamboo.")
		end
		if mcl_bamboo.is_protected(pos, placer) then
			return
		end
		if DEBUG then
			minetest.log("mcl_bamboo::placement of bamboo is not protected.")
		end

		-- Use pointed node's on_rightclick function first, if present
		if placer and not placer:get_player_control().sneak then
			if minetest.registered_nodes[node.name] and minetest.registered_nodes[node.name].on_rightclick then
				if DEBUG then
					minetest.log("mcl_bamboo::attempting placement of bamboo via targeted node's on_rightclick.")
				end
				return minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack) or itemstack
			end
		end

		if nodename ~= bamboo and nodename ~= bamboo_one and nodename ~= bamboo_two and nodename ~= bamboo_three then
			-- not bamboo...
			if nodename ~= "mcl_flowerpots:flower_pot" then
				local found = false
				for i = 1, #mcl_bamboo.bamboo_dirt_nodes do
					if nodename == mcl_bamboo.bamboo_dirt_nodes[i] then
						found = true
						break
					end
				end
				if not found then
					return itemstack
				end
			end
		end

		if DEBUG then
			minetest.log("mcl_bamboo::placing bamboo directly.")
		end
		local dir = vector.subtract(pointed_thing.under, pointed_thing.above)
		local wdir = minetest.dir_to_wallmounted(dir)
		local fdir = minetest.dir_to_facedir(dir)
		if wdir ~= 1 then
			return
		end
		local place_item = ItemStack(itemstack) -- make a copy so that we don't indirectly mess with the original.

		itemstack:set_count(itemstack:get_count() - 1)
		if nodename == bamboo then
			-- return the missing item, so that we can lower the code
			-- complexity and duplication.
			itemstack:set_count(itemstack:get_count() + 1)
			return minetest.item_place(itemstack, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
		elseif nodename == bamboo_one then
			place_item:set_name(bamboo_one)
			minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
			return itemstack, pointed_thing.under
		elseif nodename == bamboo_two then
			place_item:set_name(bamboo_two)
			minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
			return itemstack, pointed_thing.under
		elseif nodename == bamboo_three then
			place_item:set_name(bamboo_three)
			minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
			return itemstack, pointed_thing.under
		else
			local placed_type = pr:next(0, 3) -- randomly choose which one to place.
			if DEBUG then
				minetest.log("MCL_BAMBOO::Place_Bamboo_Shoot--Type: " .. placed_type)
			end
			if placed_type == 0 then
				place_item=ItemStack(bamboo)
				if DEBUG then
					minetest.log("Bamboo place_item definition (current):\n" .. dump(place_item:to_table()))
				end
				minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
				return itemstack, pointed_thing.under
			elseif placed_type == 1 then
				place_item=ItemStack(bamboo_one)
				if DEBUG then
					minetest.log("Bamboo place_item definition (current):\n" .. dump(place_item:to_table()))
				end
				minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
				return itemstack, pointed_thing.under
			elseif placed_type == 2 then
				place_item=ItemStack(bamboo_two)
				if DEBUG then
					minetest.log("Bamboo place_item definition (current):\n" .. dump(place_item:to_table()))
				end
				minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
				return itemstack, pointed_thing.under
			elseif placed_type == 3 then
				place_item=ItemStack(bamboo_three)
				if DEBUG then
					minetest.log("Bamboo place_item definition (current):\n" .. dump(place_item:to_table()))
				end
				minetest.item_place(place_item, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
				return itemstack, pointed_thing.under
			end
			return false
		end
	end,

	on_destruct = function(pos)
		-- Node destructor; called before removing node.
		local new_pos = vector.offset(pos, 0, 1, 0)
		local node_above = minetest.get_node(new_pos)
		local mboo = substr(node_above.name, strlen(node_above.name) - 3, strlen(node_above.name))
		local istack = ItemStack(bamboo)
		local sound_params = {
			pos = new_pos,
			gain = 1.0, -- default
			max_hear_distance = 10, -- default, uses a Euclidean metric
		}

		if node_above and (mboo == "mboo" or mboo == "oo_1" or mboo == "oo_2" or mboo == "oo_3") then
			minetest.remove_node(new_pos)
			minetest.sound_play(node_sound.dug, sound_params, true)
			if pr:next(1, DOUBLE_DROP_CHANCE) == 1 then
				minetest.add_item(new_pos, istack)
			end
			minetest.add_item(new_pos, istack)
		elseif node_above and node_above.name == "mcl_bamboo:bamboo_endcap" then
			minetest.remove_node(new_pos)
			minetest.sound_play(node_sound.dug, sound_params, true)
			minetest.add_item(new_pos, istack)
			if pr:next(1, DOUBLE_DROP_CHANCE) == 1 then
				minetest.add_item(new_pos, istack)
			end
		end
	end,
}
minetest.register_node(bamboo, bamboo_def)

local bamboo_top = table.copy(bamboo_def)
bamboo_top.groups = {not_in_creative_inventory = 1, handy = 1, axey = 1, choppy = 1, flammable = 3}
bamboo_top.tiles = {"mcl_bamboo_flower_pot.png"}
bamboo_top.drawtype = "plantlike"
bamboo_top.paramtype2 = "meshoptions"
bamboo_top.param2 = 34
bamboo_top.nodebox = nil

bamboo_top.on_place = function(itemstack, _, _)
	-- Should never occur... but, if it does, then nix it.
	itemstack:set_name(bamboo)
	return itemstack
end

minetest.register_node("mcl_bamboo:bamboo_endcap", bamboo_top)

local bamboo_block_def = {
	description = "Bamboo Block",
	tiles = {"mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo_block.png"},
	groups = {handy = 1, building_block = 1, axey = 1, flammable = 2, material_wood = 1, bamboo_block = 1, fire_encouragement = 5, fire_flammability = 5},
	sounds = node_sound,
	paramtype2 = "facedir",
	drops = "mcl_bamboo:bamboo_block",
	_mcl_blast_resistance = 3,
	_mcl_hardness = 2,
	_mcl_stripped_variant = "mcl_bamboo:bamboo_block_stripped", -- this allows us to use the built in Axe's strip block.
	on_place = function(itemstack, placer, pointed_thing)

		local pos = pointed_thing.under

		if mcl_bamboo.is_protected(pos, placer) then
			return
		end

		-- Use pointed node's on_rightclick function first, if present
		local node = minetest.get_node(pointed_thing.under)
		if placer and not placer:get_player_control().sneak then
			if minetest.registered_nodes[node.name] and minetest.registered_nodes[node.name].on_rightclick then
				return minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack) or itemstack
			end
		end

		return minetest.item_place(itemstack, placer, pointed_thing, minetest.dir_to_facedir(vector.direction(pointed_thing.above, pointed_thing.under)))
	end,

}

minetest.register_node("mcl_bamboo:bamboo_block", bamboo_block_def)

local bamboo_stripped_block = table.copy(bamboo_block_def)
bamboo_stripped_block.on_rightclick = nil
bamboo_stripped_block.description = S("Stripped Bamboo Block")
bamboo_stripped_block.tiles = {"mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo_block_stripped.png"}
minetest.register_node("mcl_bamboo:bamboo_block_stripped", bamboo_stripped_block)
minetest.register_node("mcl_bamboo:bamboo_plank", {
	description = S("Bamboo Plank"),
	_doc_items_longdesc = S("Bamboo Plank"),
	_doc_items_hidden = false,
	tiles = {"mcl_bamboo_bamboo_plank.png"},
	stack_max = 64,
	is_ground_content = false,
	groups = {handy = 1, axey = 1, flammable = 3, wood = 1, building_block = 1, material_wood = 1, fire_encouragement = 5, fire_flammability = 20},
	sounds = mcl_sounds.node_sound_wood_defaults(),
	_mcl_blast_resistance = 3,
	_mcl_hardness = 2,
})

-- Bamboo Part 2 Base nodes.
-- Bamboo alternative node types. Note that the table.copy's are very important! if you use a common node def and
-- make changes, even after registering them, the changes overwrite the previous node definitions, and in this case,
-- you will end up with 4 nodes all being type 3.
local bamboo_one_def = table.copy(bamboo_def)
bamboo_one_def.node_box = {
	type = "fixed",
	fixed = {
		{-0.05, -0.5, 0.285, -0.275, 0.5, 0.06},
	}
}
bamboo_one_def.collision_box = {
	-- see [Node boxes] for possibilities
	type = "fixed",
	fixed = {
		{-0.05, -0.5, 0.285, -0.275, 0.5, 0.06},
	}
}
bamboo_one_def.selection_box = {
	type = "fixed",
	fixed = {
		{-0.05, -0.5, 0.285, -0.275, 0.5, 0.06},
	}
}
minetest.register_node(bamboo_one, bamboo_one_def)
local bamboo_two_def = table.copy(bamboo_def)

bamboo_two_def.node_box = {
	type = "fixed",
	fixed = {
		{0.25, -0.5, 0.325, 0.025, 0.5, 0.100},
	}
}
bamboo_two_def.collision_box = {
	-- see [Node boxes] for possibilities
	type = "fixed",
	fixed = {
		{0.25, -0.5, 0.325, 0.025, 0.5, 0.100},
	}
}
bamboo_two_def.selection_box = {
	type = "fixed",
	fixed = {
		{0.25, -0.5, 0.325, 0.025, 0.5, 0.100},
	}
}
minetest.register_node(bamboo_two, bamboo_two_def)
local bamboo_three_def = table.copy(bamboo_def)

bamboo_three_def.node_box = {
	type = "fixed",
	fixed = {
		{-0.125, -0.5, 0.125, -0.3125, 0.5, 0.3125},
	}
}
bamboo_three_def.collision_box = {
	-- see [Node boxes] for possibilities
	type = "fixed",
	fixed = {
		{-0.125, -0.5, 0.125, -0.3125, 0.5, 0.3125},
	}
}
bamboo_three_def.selection_box = {
	type = "fixed",
	fixed = {
		{-0.125, -0.5, 0.125, -0.3125, 0.5, 0.3125},
	}
}
minetest.register_node(bamboo_three, bamboo_three_def)
